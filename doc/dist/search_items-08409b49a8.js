searchNodes=[{"doc":"Constant module to be used inside framework core. Contatins only base constants which are shared between all simulations.","ref":"Simulator.BaseConstants.html","title":"Simulator.BaseConstants","type":"module"},{"doc":"Callback implementation for Simulator.Constants.define_constants/0 .","ref":"Simulator.BaseConstants.html#define_constants/0","title":"Simulator.BaseConstants.define_constants/0","type":"macro"},{"doc":"Module which should be used by exactly one module in every simulation. That module will be called Cell module. Using module have to implement two functions: generate_signal/1 - for given object returns signal that it generates; signal_factor/1 - for given object returns signal factor - value by which the signal is multiplied when encounters that object. See Evacuation.Cell in the examples directory for the exemplary usage.","ref":"Simulator.Cell.html","title":"Simulator.Cell","type":"behaviour"},{"doc":"","ref":"Simulator.Cell.html#c:generate_signal/1","title":"Simulator.Cell.generate_signal/1","type":"callback"},{"doc":"","ref":"Simulator.Cell.html#c:signal_factor/1","title":"Simulator.Cell.signal_factor/1","type":"callback"},{"doc":"Module which should be used in the Constant module in every simulation. Constant module provides other modules with useful constants (as Nx requires numbers, it is a workaround to make code more readables). Using the module requires implementing define_constants/0 macro. Its exemplary body can be seen in Evacuation.Constants module in the examples directory. Attributes inside the macro are specific to the simulation. After defining Constant module ( using this one), it can be used by other modules in the simulation to provide them with needed constants (the ones defined below and other defined by the framework user).","ref":"Simulator.Constants.html","title":"Simulator.Constants","type":"behaviour"},{"doc":"","ref":"Simulator.Constants.html#c:define_constants/0","title":"Simulator.Constants.define_constants/0","type":"macrocallback"},{"doc":"Module containing useful functions ( defn s).","ref":"Simulator.Helpers.html","title":"Simulator.Helpers","type":"module"},{"doc":"Checks whether a == a_ref and b == b_ref .","ref":"Simulator.Helpers.html#both_equal/4","title":"Simulator.Helpers.both_equal/4","type":"function"},{"doc":"Checks if position {x, y} is inside the grid.","ref":"Simulator.Helpers.html#is_valid/2","title":"Simulator.Helpers.is_valid/2","type":"function"},{"doc":"Checks whether plan_a == plan_b .","ref":"Simulator.Helpers.html#plans_match/2","title":"Simulator.Helpers.plans_match/2","type":"function"},{"doc":"Checks whether plan_a == plan_b and object_a == object_b .","ref":"Simulator.Helpers.html#plans_objects_match/4","title":"Simulator.Helpers.plans_objects_match/4","type":"function"},{"doc":"Puts object to the grid[x][y][0] .","ref":"Simulator.Helpers.html#put_object/4","title":"Simulator.Helpers.put_object/4","type":"function"},{"doc":"Returns coordinates of the cell being in direction from the given { x , y }.","ref":"Simulator.Helpers.html#shift/2","title":"Simulator.Helpers.shift/2","type":"function"},{"doc":"Module which should be used by exactly one module in every simulation. That module will be called Metrics module. The only callback is calculate_metrics/6 . Among them arguments it receives metrics from previous iterations and returns new ones.","ref":"Simulator.Metrics.html","title":"Simulator.Metrics","type":"behaviour"},{"doc":"","ref":"Simulator.Metrics.html#c:calculate_metrics/6","title":"Simulator.Metrics.calculate_metrics/6","type":"callback"},{"doc":"Module which should be used by exactly one module in every simulation. That module will be called PlanCreator module. Using module have to implement function create_plan/5 which will be responsible for creating plans for every dynamic object in the simulation. Function should return a tuple {direction, plan} where plan is a one dimensional tensor with two elements: [action, consequence] . See Evacuation.PlanCreator in the examples directory for the exemplary usage.","ref":"Simulator.PlanCreator.html","title":"Simulator.PlanCreator","type":"behaviour"},{"doc":"","ref":"Simulator.PlanCreator.html#c:create_plan/5","title":"Simulator.PlanCreator.create_plan/5","type":"callback"},{"doc":"Module which should be used by exactly one module in every simulation. That module will be called PlanResolver module. It has to implement three functions: is_update_valid?/2 - which will be responsible for checking whether the action can be applied to the object ; apply_action/3 - which should return new object and state for the location of the action of the plan. apply_consequence/3 - which should return new object and state for the old object location. See Evacuation.PlanResolver in the examples directory for the exemplary usage.","ref":"Simulator.PlanResolver.html","title":"Simulator.PlanResolver","type":"behaviour"},{"doc":"","ref":"Simulator.PlanResolver.html#c:apply_action/3","title":"Simulator.PlanResolver.apply_action/3","type":"callback"},{"doc":"","ref":"Simulator.PlanResolver.html#c:apply_consequence/3","title":"Simulator.PlanResolver.apply_consequence/3","type":"callback"},{"doc":"","ref":"Simulator.PlanResolver.html#c:is_update_valid?/2","title":"Simulator.PlanResolver.is_update_valid?/2","type":"callback"},{"doc":"Module responsible for saving visualization data and metrics to the files. Additionally contatins functions helpful in debugging.","ref":"Simulator.Printer.html","title":"Simulator.Printer","type":"module"},{"doc":"Delete all the contents of the directory with files for visualization.","ref":"Simulator.Printer.html#clean_grid_iterations/0","title":"Simulator.Printer.clean_grid_iterations/0","type":"function"},{"doc":"Creates directory for metrics of the worker located in { x , y }.","ref":"Simulator.Printer.html#create_metrics_directory/1","title":"Simulator.Printer.create_metrics_directory/1","type":"function"},{"doc":"Creates directory for visualization of the grid of the worker located in { x , y }.","ref":"Simulator.Printer.html#create_visualization_directory/1","title":"Simulator.Printer.create_visualization_directory/1","type":"function"},{"doc":"Prints given grid .","ref":"Simulator.Printer.html#print/2","title":"Simulator.Printer.print/2","type":"function"},{"doc":"Prints 3D tensor in readable way. Useful during debugging.","ref":"Simulator.Printer.html#print_3d_tensor/2","title":"Simulator.Printer.print_3d_tensor/2","type":"function"},{"doc":"Prints accepted plans in readable way. Useful during debugging.","ref":"Simulator.Printer.html#print_accepted_plans/2","title":"Simulator.Printer.print_accepted_plans/2","type":"function"},{"doc":"Prints only the objects from the given grid .","ref":"Simulator.Printer.html#print_objects/2","title":"Simulator.Printer.print_objects/2","type":"function"},{"doc":"Prints objects state in readable way. Useful during debugging.","ref":"Simulator.Printer.html#print_objects_state/2","title":"Simulator.Printer.print_objects_state/2","type":"function"},{"doc":"Writes grid as tensor to file. Firstly, it is converted to string.","ref":"Simulator.Printer.html#write_to_file/1","title":"Simulator.Printer.write_to_file/1","type":"function"},{"doc":"Entry point. Every simulation should call Simulator.Simulation.start/5.","ref":"Simulator.Simulation.html","title":"Simulator.Simulation","type":"module"},{"doc":"","ref":"Simulator.Simulation.html#get_next_node/4","title":"Simulator.Simulation.get_next_node/4","type":"function"},{"doc":"","ref":"Simulator.Simulation.html#shift/2","title":"Simulator.Simulation.shift/2","type":"function"},{"doc":"","ref":"Simulator.Simulation.html#split_grid_among_workers/5","title":"Simulator.Simulation.split_grid_among_workers/5","type":"function"},{"doc":"","ref":"Simulator.Simulation.html#start/5","title":"Simulator.Simulation.start/5","type":"function"},{"doc":"Module containing type shared between modules in the Simulator.","ref":"Simulator.Types.html","title":"Simulator.Types","type":"module"},{"doc":"","ref":"Simulator.Types.html#t:index/0","title":"Simulator.Types.index/0","type":"type"},{"doc":"GenServer responsible for simulating one shard. There are three phases of every iteration: :remote_plans - plans are processed. Some of them are accepted, some discarded. Result of the processing is distributed among neighboring shards; :remote_consequences - consequences derived from the accepted plans are applied to the grid. Additionally, signal update is calculated and distributed to the neighboring shards; :remote_signal - signal is applied to the grid. Next iteration is started. If iteration's number does not exceed the maximum number of iterations set in the cofiguration, plans are created and distributed to the neighboring shards; First iteration starts with creating plans, so it is in the middle of :remote_signal phase.","ref":"Simulator.WorkerActor.html","title":"Simulator.WorkerActor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Simulator.WorkerActor.html#child_spec/1","title":"Simulator.WorkerActor.child_spec/1","type":"function"},{"doc":"Starts the WorkerActor. TODO use some supervisor.","ref":"Simulator.WorkerActor.html#start/1","title":"Simulator.WorkerActor.start/1","type":"function"},{"doc":"","ref":"Simulator.WorkerActor.html#unstash_messages/1","title":"Simulator.WorkerActor.unstash_messages/1","type":"function"},{"doc":"Module contataining a Worker's function responsible for the consequences.","ref":"Simulator.WorkerActor.Consequences.html","title":"Simulator.WorkerActor.Consequences","type":"module"},{"doc":"Applies all consequences from the accepted plans.","ref":"Simulator.WorkerActor.Consequences.html#apply_consequences/5","title":"Simulator.WorkerActor.Consequences.apply_consequences/5","type":"function"},{"doc":"Module contataining Worker's functions responsible for the plans. Each plan is a tensor: [direction, action, consequence]. direction - a plan contains an action towards a specific neighboring cell. Direction indicates it. action - what should be the state of the target cell (pointed by direction ). consequence - what should be in the current cell if the plan will be executed. Example: a person wants to move up: [@dir_up, @person, @empty].","ref":"Simulator.WorkerActor.Plans.html","title":"Simulator.WorkerActor.Plans","type":"module"},{"doc":"Creates plans for every cell in the grid.","ref":"Simulator.WorkerActor.Plans.html#create_plans/4","title":"Simulator.WorkerActor.Plans.create_plans/4","type":"function"},{"doc":"The function decides which plans are accepted and update the grid by putting action in the proper cells. Consequences will be applied in the :remote_consequences phase.","ref":"Simulator.WorkerActor.Plans.html#process_plans/5","title":"Simulator.WorkerActor.Plans.process_plans/5","type":"function"},{"doc":"Module contataining Worker's functions responsible for the signal.","ref":"Simulator.WorkerActor.Signal.html","title":"Simulator.WorkerActor.Signal","type":"module"},{"doc":"Applies signal update. Cuts out only signal (without object) from grid and signal_update , performs applying update and puts result back to the grid . Applying update is making such an operation on every signal value {i, j, dir}: s[i][j][dir] = (s[i][j][dir] + S u[i][j][dir]) A * f(g[i][j][0]) where: s - a signal grid (3D tensor cut out from grid ); u - passed signal update (3D tensor); g - passed grid ; S - @signal_suppression_factor ; A - @signal_attenuation_factor ; f - signal_factor function - returned value depends on the contents of the cell.","ref":"Simulator.WorkerActor.Signal.html#apply_signal_update/3","title":"Simulator.WorkerActor.Signal.apply_signal_update/3","type":"function"},{"doc":"Calculates signal update for all cells.","ref":"Simulator.WorkerActor.Signal.html#calculate_signal_updates/2","title":"Simulator.WorkerActor.Signal.calculate_signal_updates/2","type":"function"},{"doc":"Framework for creating generic distributed simulations. It requires implementing a few callbacks to create a new simulation. There are two example simulations for reference: Evacuation Rabbits and Lettuce","ref":"readme.html","title":"Distributed Simulator","type":"extras"},{"doc":"It requires Elixir 1.11 or newer and Erlang 22 or newer.","ref":"readme.html#installation","title":"Distributed Simulator - Installation","type":"extras"},{"doc":"Framework works only with some simulation. However, you can run tests. Firstly, download dependencies: mix deps.get And then run the tests: mix test","ref":"readme.html#testing","title":"Distributed Simulator - Testing","type":"extras"},{"doc":"Documentation can be generated with ExDoc .","ref":"readme.html#documentation","title":"Distributed Simulator - Documentation","type":"extras"}]